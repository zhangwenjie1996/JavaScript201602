<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script type="text/javascript">
    function CreateJsPerson(name, age) {
        //->当执行的时候,首先还会像普通的函数执行一样,形成一个私有的作用域,形参赋值,预解释,代码开始自上而下执行
        //->如果是new执行的,在这里代码执行之前又多加了一步浏览器默认的操作：浏览器默认的创建一个对象数据类型的值（就是当前这个类的实例）
        //->代码执行:
        //->把默认创建的实例当做执行的主体(this),通过this.xxx=xxx的方式给当前实例增加一些属性和方法
        this.name = name;
        this.age = age;
        this.writeJs = function () {
            console.log("my name is " + this.name + "，i am " + this.age + " years old，i can write javascript 啦~~");
        };
        //->我们不需要手动的写return,浏览器会默认的把当前创建的实例返回
    }

    //var jsPerson1 = createJsPerson("宫之晓", 40);//->普通函数执行
    var jsPerson1 = new CreateJsPerson("宫之晓", 40);//->构造函数模式执行 此时的CreateJsPerson就不在仅仅是一个普通的方法名了，而是一个类；同理,jsPerson1就不单单是一个变量了，而是这个类的一个实例;

    var jsPerson2 = new CreateJsPerson("霍月林", 17);


    //->社会上很多后台转前端的大部分都认为，我们写的构造函数模式才是单例模式，但是在前端我们第一种写法才是单例模式，和后台是不一样的
    //->我们那个为啥也说是单例模式呢?因为不管是obj1,还是obj2都是Object这个基类的两个不同的实例,obj1和obj2也是单独的个体,所以它是“单例模式”;
    var obj1 = {};//->字面量方式创建  var obj1=new Object(); 构造函数模式创建(实例创建)
    var obj2 = {};//->字面量方式创建  var obj2=new Object();

</script>
</body>
</html>